//===----------------------------------------------------------------------===//
//
// This source file is part of the AWSSDKSwift open source project
//
// Copyright (c) 2017-2020 the AWSSDKSwift project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of AWSSDKSwift project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/swift-aws/aws-sdk-swift/blob/master/CodeGenerator/Sources/CodeGenerator/main.swift. DO NOT EDIT.

@_exported import AWSSDKSwiftCore

/**
Client object for interacting with AWS RoboMaker service.

This section provides documentation for the AWS RoboMaker API operations.
*/
public struct RoboMaker: AWSService {

    //MARK: Member variables

    public let client: AWSClient
    public let config: AWSServiceConfig
    public let context: AWSServiceContext

    //MARK: Initialization

    /// Initialize the RoboMaker client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - timeout: Timeout value for HTTP requests
    public init(
        client: AWSClient,
        region: AWSSDKSwiftCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        timeout: TimeAmount? = nil
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            service: "robomaker",
            serviceProtocol: .restjson,
            apiVersion: "2018-06-29",
            endpoint: endpoint,
            possibleErrorTypes: [RoboMakerErrorType.self]        )
        self.context = .init(timeout: timeout ?? .seconds(20))
    }
    
    /// create copy of service with new context
    public func withNewContext(_ process: (AWSServiceContext) -> AWSServiceContext) -> Self {
        return Self(client: self.client, config: self.config, context: process(self.context))
    }
    
    //MARK: API Calls

    ///  Describes one or more simulation jobs.
    public func batchDescribeSimulationJob(_ input: BatchDescribeSimulationJobRequest) -> EventLoopFuture<BatchDescribeSimulationJobResponse> {
        return client.execute(operation: "BatchDescribeSimulationJob", path: "/batchDescribeSimulationJob", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Cancels the specified deployment job.
    public func cancelDeploymentJob(_ input: CancelDeploymentJobRequest) -> EventLoopFuture<CancelDeploymentJobResponse> {
        return client.execute(operation: "CancelDeploymentJob", path: "/cancelDeploymentJob", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Cancels the specified simulation job.
    public func cancelSimulationJob(_ input: CancelSimulationJobRequest) -> EventLoopFuture<CancelSimulationJobResponse> {
        return client.execute(operation: "CancelSimulationJob", path: "/cancelSimulationJob", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Cancels a simulation job batch. When you cancel a simulation job batch, you are also cancelling all of the active simulation jobs created as part of the batch. 
    public func cancelSimulationJobBatch(_ input: CancelSimulationJobBatchRequest) -> EventLoopFuture<CancelSimulationJobBatchResponse> {
        return client.execute(operation: "CancelSimulationJobBatch", path: "/cancelSimulationJobBatch", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Deploys a specific version of a robot application to robots in a fleet. The robot application must have a numbered applicationVersion for consistency reasons. To create a new version, use CreateRobotApplicationVersion or see Creating a Robot Application Version.   After 90 days, deployment jobs expire and will be deleted. They will no longer be accessible.  
    public func createDeploymentJob(_ input: CreateDeploymentJobRequest) -> EventLoopFuture<CreateDeploymentJobResponse> {
        return client.execute(operation: "CreateDeploymentJob", path: "/createDeploymentJob", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Creates a fleet, a logical group of robots running the same robot application.
    public func createFleet(_ input: CreateFleetRequest) -> EventLoopFuture<CreateFleetResponse> {
        return client.execute(operation: "CreateFleet", path: "/createFleet", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Creates a robot.
    public func createRobot(_ input: CreateRobotRequest) -> EventLoopFuture<CreateRobotResponse> {
        return client.execute(operation: "CreateRobot", path: "/createRobot", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Creates a robot application. 
    public func createRobotApplication(_ input: CreateRobotApplicationRequest) -> EventLoopFuture<CreateRobotApplicationResponse> {
        return client.execute(operation: "CreateRobotApplication", path: "/createRobotApplication", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Creates a version of a robot application.
    public func createRobotApplicationVersion(_ input: CreateRobotApplicationVersionRequest) -> EventLoopFuture<CreateRobotApplicationVersionResponse> {
        return client.execute(operation: "CreateRobotApplicationVersion", path: "/createRobotApplicationVersion", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Creates a simulation application.
    public func createSimulationApplication(_ input: CreateSimulationApplicationRequest) -> EventLoopFuture<CreateSimulationApplicationResponse> {
        return client.execute(operation: "CreateSimulationApplication", path: "/createSimulationApplication", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Creates a simulation application with a specific revision id.
    public func createSimulationApplicationVersion(_ input: CreateSimulationApplicationVersionRequest) -> EventLoopFuture<CreateSimulationApplicationVersionResponse> {
        return client.execute(operation: "CreateSimulationApplicationVersion", path: "/createSimulationApplicationVersion", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Creates a simulation job.  After 90 days, simulation jobs expire and will be deleted. They will no longer be accessible.  
    public func createSimulationJob(_ input: CreateSimulationJobRequest) -> EventLoopFuture<CreateSimulationJobResponse> {
        return client.execute(operation: "CreateSimulationJob", path: "/createSimulationJob", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Deletes a fleet.
    public func deleteFleet(_ input: DeleteFleetRequest) -> EventLoopFuture<DeleteFleetResponse> {
        return client.execute(operation: "DeleteFleet", path: "/deleteFleet", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Deletes a robot.
    public func deleteRobot(_ input: DeleteRobotRequest) -> EventLoopFuture<DeleteRobotResponse> {
        return client.execute(operation: "DeleteRobot", path: "/deleteRobot", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Deletes a robot application.
    public func deleteRobotApplication(_ input: DeleteRobotApplicationRequest) -> EventLoopFuture<DeleteRobotApplicationResponse> {
        return client.execute(operation: "DeleteRobotApplication", path: "/deleteRobotApplication", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Deletes a simulation application.
    public func deleteSimulationApplication(_ input: DeleteSimulationApplicationRequest) -> EventLoopFuture<DeleteSimulationApplicationResponse> {
        return client.execute(operation: "DeleteSimulationApplication", path: "/deleteSimulationApplication", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Deregisters a robot.
    public func deregisterRobot(_ input: DeregisterRobotRequest) -> EventLoopFuture<DeregisterRobotResponse> {
        return client.execute(operation: "DeregisterRobot", path: "/deregisterRobot", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Describes a deployment job.
    public func describeDeploymentJob(_ input: DescribeDeploymentJobRequest) -> EventLoopFuture<DescribeDeploymentJobResponse> {
        return client.execute(operation: "DescribeDeploymentJob", path: "/describeDeploymentJob", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Describes a fleet.
    public func describeFleet(_ input: DescribeFleetRequest) -> EventLoopFuture<DescribeFleetResponse> {
        return client.execute(operation: "DescribeFleet", path: "/describeFleet", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Describes a robot.
    public func describeRobot(_ input: DescribeRobotRequest) -> EventLoopFuture<DescribeRobotResponse> {
        return client.execute(operation: "DescribeRobot", path: "/describeRobot", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Describes a robot application.
    public func describeRobotApplication(_ input: DescribeRobotApplicationRequest) -> EventLoopFuture<DescribeRobotApplicationResponse> {
        return client.execute(operation: "DescribeRobotApplication", path: "/describeRobotApplication", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Describes a simulation application.
    public func describeSimulationApplication(_ input: DescribeSimulationApplicationRequest) -> EventLoopFuture<DescribeSimulationApplicationResponse> {
        return client.execute(operation: "DescribeSimulationApplication", path: "/describeSimulationApplication", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Describes a simulation job.
    public func describeSimulationJob(_ input: DescribeSimulationJobRequest) -> EventLoopFuture<DescribeSimulationJobResponse> {
        return client.execute(operation: "DescribeSimulationJob", path: "/describeSimulationJob", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Describes a simulation job batch.
    public func describeSimulationJobBatch(_ input: DescribeSimulationJobBatchRequest) -> EventLoopFuture<DescribeSimulationJobBatchResponse> {
        return client.execute(operation: "DescribeSimulationJobBatch", path: "/describeSimulationJobBatch", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Returns a list of deployment jobs for a fleet. You can optionally provide filters to retrieve specific deployment jobs. 
    public func listDeploymentJobs(_ input: ListDeploymentJobsRequest) -> EventLoopFuture<ListDeploymentJobsResponse> {
        return client.execute(operation: "ListDeploymentJobs", path: "/listDeploymentJobs", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Returns a list of fleets. You can optionally provide filters to retrieve specific fleets. 
    public func listFleets(_ input: ListFleetsRequest) -> EventLoopFuture<ListFleetsResponse> {
        return client.execute(operation: "ListFleets", path: "/listFleets", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Returns a list of robot application. You can optionally provide filters to retrieve specific robot applications.
    public func listRobotApplications(_ input: ListRobotApplicationsRequest) -> EventLoopFuture<ListRobotApplicationsResponse> {
        return client.execute(operation: "ListRobotApplications", path: "/listRobotApplications", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Returns a list of robots. You can optionally provide filters to retrieve specific robots.
    public func listRobots(_ input: ListRobotsRequest) -> EventLoopFuture<ListRobotsResponse> {
        return client.execute(operation: "ListRobots", path: "/listRobots", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Returns a list of simulation applications. You can optionally provide filters to retrieve specific simulation applications. 
    public func listSimulationApplications(_ input: ListSimulationApplicationsRequest) -> EventLoopFuture<ListSimulationApplicationsResponse> {
        return client.execute(operation: "ListSimulationApplications", path: "/listSimulationApplications", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Returns a list simulation job batches. You can optionally provide filters to retrieve specific simulation batch jobs. 
    public func listSimulationJobBatches(_ input: ListSimulationJobBatchesRequest) -> EventLoopFuture<ListSimulationJobBatchesResponse> {
        return client.execute(operation: "ListSimulationJobBatches", path: "/listSimulationJobBatches", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Returns a list of simulation jobs. You can optionally provide filters to retrieve specific simulation jobs. 
    public func listSimulationJobs(_ input: ListSimulationJobsRequest) -> EventLoopFuture<ListSimulationJobsResponse> {
        return client.execute(operation: "ListSimulationJobs", path: "/listSimulationJobs", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Lists all tags on a AWS RoboMaker resource.
    public func listTagsForResource(_ input: ListTagsForResourceRequest) -> EventLoopFuture<ListTagsForResourceResponse> {
        return client.execute(operation: "ListTagsForResource", path: "/tags/{resourceArn}", httpMethod: .GET, input: input, config: self.config, context: self.context)
    }

    ///  Registers a robot with a fleet.
    public func registerRobot(_ input: RegisterRobotRequest) -> EventLoopFuture<RegisterRobotResponse> {
        return client.execute(operation: "RegisterRobot", path: "/registerRobot", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Restarts a running simulation job.
    public func restartSimulationJob(_ input: RestartSimulationJobRequest) -> EventLoopFuture<RestartSimulationJobResponse> {
        return client.execute(operation: "RestartSimulationJob", path: "/restartSimulationJob", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Starts a new simulation job batch. The batch is defined using one or more SimulationJobRequest objects. 
    public func startSimulationJobBatch(_ input: StartSimulationJobBatchRequest) -> EventLoopFuture<StartSimulationJobBatchResponse> {
        return client.execute(operation: "StartSimulationJobBatch", path: "/startSimulationJobBatch", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Syncrhonizes robots in a fleet to the latest deployment. This is helpful if robots were added after a deployment.
    public func syncDeploymentJob(_ input: SyncDeploymentJobRequest) -> EventLoopFuture<SyncDeploymentJobResponse> {
        return client.execute(operation: "SyncDeploymentJob", path: "/syncDeploymentJob", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Adds or edits tags for a AWS RoboMaker resource. Each tag consists of a tag key and a tag value. Tag keys and tag values are both required, but tag values can be empty strings.  For information about the rules that apply to tag keys and tag values, see User-Defined Tag Restrictions in the AWS Billing and Cost Management User Guide. 
    public func tagResource(_ input: TagResourceRequest) -> EventLoopFuture<TagResourceResponse> {
        return client.execute(operation: "TagResource", path: "/tags/{resourceArn}", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Removes the specified tags from the specified AWS RoboMaker resource. To remove a tag, specify the tag key. To change the tag value of an existing tag key, use  TagResource . 
    public func untagResource(_ input: UntagResourceRequest) -> EventLoopFuture<UntagResourceResponse> {
        return client.execute(operation: "UntagResource", path: "/tags/{resourceArn}", httpMethod: .DELETE, input: input, config: self.config, context: self.context)
    }

    ///  Updates a robot application.
    public func updateRobotApplication(_ input: UpdateRobotApplicationRequest) -> EventLoopFuture<UpdateRobotApplicationResponse> {
        return client.execute(operation: "UpdateRobotApplication", path: "/updateRobotApplication", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Updates a simulation application.
    public func updateSimulationApplication(_ input: UpdateSimulationApplicationRequest) -> EventLoopFuture<UpdateSimulationApplicationResponse> {
        return client.execute(operation: "UpdateSimulationApplication", path: "/updateSimulationApplication", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }
}

extension RoboMaker {
    /// internal initialiser used by `withNewContext`
    init(client: AWSClient, config: AWSServiceConfig, context: AWSServiceContext) {
        self.client = client
        self.config = config
        self.context = context
    }
}
